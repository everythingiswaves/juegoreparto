<!--
  Juego interactivo de Reparto Equitativo para segundo grado (p5.js).
  Permite a los alumnos arrastrar c칤rculos a rect치ngulos (grupos)
  y verifica si el reparto ha sido equitativo.

  EDICI칍N: Se ha implementado un sistema de grilla (Grid Positioning)
  dentro de cada rect치ngulo para ordenar los c칤rculos al ser soltados.
-->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reparto Equitativo con C칤rculos</title>
    <!-- Carga de la librer칤a p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Estilos usando Tailwind CSS (cargado via CDN) para la interfaz */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; /* Fondo suave */
            font-family: 'Inter', sans-serif;
            flex-direction: column;
        }
        #p5-canvas-container {
            border: 4px solid #3b82f6; /* Borde azul llamativo */
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        .instructions {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            text-align: center;
            max-width: 800px;
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 10px;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            box-shadow: 0 4px #1d4ed8;
            font-size: 1rem;
        }
        .btn-check {
            background-color: #4ade80; /* Verde brillante */
            color: #166534;
        }
        .btn-check:hover {
            background-color: #10b981;
            box-shadow: 0 2px #065f46;
            transform: translateY(2px);
        }
        .btn-reset {
            background-color: #facc15; /* Amarillo */
            color: #713f12;
        }
        .btn-reset:hover {
            background-color: #f59e0b;
            box-shadow: 0 2px #b45309;
            transform: translateY(2px);
        }
        #message {
            margin-top: 15px;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            min-height: 20px;
        }
        .message-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        .message-error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
    </style>
</head>
<body>

    <div class="instructions">
        <h2>游꿡 춰A Repartir C칤rculos!</h2>
        <p id="problem-text">
            El objetivo es **repartir** todos los c칤rculos de abajo en los rect치ngulos de arriba,
            asegurando que **cada rect치ngulo quede con la misma cantidad** de c칤rculos.
        </p>
    </div>

    <div id="p5-canvas-container"></div>

    <div id="message"></div>

    <div class="controls">
        <button class="btn btn-check" onclick="checkReparto()">춰Comprobar!</button>
        <button class="btn btn-reset" onclick="resetGame()">Nuevo Reto</button>
    </div>

    <script>
        // --- Variables Globales del Juego ---
        let circles = []; // Array de c칤rculos (objetos a repartir)
        let targets = []; // Array de rect치ngulos (grupos receptores)
        let numCircles;
        let numTargets;
        let circleSize = 30;
        let padding = 20;
        let canvasWidth = 800;
        let canvasHeight = 550;
        let isDragging = false;
        let draggedCircle = null;
        let messageDiv;
        
        // Par치metros de la grilla dentro de los rect치ngulos (Targets)
        const gridSpacing = 35; // Espacio entre centros de c칤rculos
        const circlesPerRowCount = 2; // M치ximo de c칤rculos por fila dentro del target

        // --- Funciones de Utilidad ---

        /**
         * Calcula las coordenadas X, Y para centrar un c칤rculo en una grilla de un Target.
         * @param {Object} target - El objeto rect치ngulo (target).
         * @param {number} index - El 칤ndice (0-based) del c칤rculo dentro de ese target.
         * @returns {Object} {x, y} - Las coordenadas centrales para el c칤rculo.
         */
        function calculateGridPosition(target, index) {
            // Posici칩n relativa a 0,0 del target
            let col = index % circlesPerRowCount;
            let row = floor(index / circlesPerRowCount);
            
            // Margen inicial para centrar la peque침a grilla
            let startX = target.x + (target.w / 2) - ((circlesPerRowCount - 1) * gridSpacing / 2);
            let startY = target.y + (target.h / 2) - (gridSpacing / 2); // Centrado verticalmente
            
            // Coordenadas absolutas
            return {
                x: startX + col * gridSpacing,
                y: startY + row * gridSpacing
            };
        }


        // --- Configuraci칩n Inicial ---

        function setup() {
            // Crea el lienzo de p5.js
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('p5-canvas-container'); // Adjunta el canvas al div contenedor
            messageDiv = document.getElementById('message');
            resetGame();
        }

        /**
         * Inicializa o reinicia el juego generando nuevos n칰meros y objetos.
         */
        function resetGame() {
            // 1. Generar n칰meros aleatorios para c칤rculos y rect치ngulos
            // Queremos que numCircles sea divisible por numTargets.
            // numTargets (grupos) entre 2 y 5
            numTargets = floor(random(2, 6));

            // numCircles (objetos) debe ser un m칰ltiplo de numTargets y estar entre 8 y 20
            let multiples = [];
            for (let i = 2; i <= 4; i++) { // Cocientes posibles: 2, 3, 4
                let value = numTargets * i;
                if (value >= 8 && value <= 20) {
                    multiples.push(value);
                }
            }
            if (multiples.length > 0) {
                numCircles = random(multiples);
            } else {
                // Fallback si no se puede generar un n칰mero adecuado, forzar uno
                numTargets = 3;
                numCircles = 12;
            }

            // Limpiar arrays
            circles = [];
            targets = [];
            messageDiv.textContent = "";
            messageDiv.className = "message";
            
            // 2. Crear los rect치ngulos (Targets) en la parte superior
            let targetHeight = 150; // Aumentamos la altura para acomodar la grilla
            let targetY = padding;
            let targetWidth = (canvasWidth - padding * (numTargets + 1)) / numTargets;

            for (let i = 0; i < numTargets; i++) {
                let x = padding + i * (targetWidth + padding);
                targets.push({
                    x: x,
                    y: targetY,
                    w: targetWidth,
                    h: targetHeight,
                    count: 0, // Contador de c칤rculos en este rect치ngulo
                    id: i,
                    circlesInTarget: [], // NUEVO: Almacena referencias a los c칤rculos dentro, por orden de llegada
                });
            }

            // 3. Crear los c칤rculos (Objects) en la parte inferior
            // Se colocar치n en una cuadr칤cula en la parte inferior del canvas.
            let startY = canvasHeight - 100; // Fila inicial
            let maxCols = floor(canvasWidth / (circleSize + padding));
            let col = 0;
            let row = 0;

            for (let i = 0; i < numCircles; i++) {
                let x = padding + circleSize / 2 + col * (circleSize + padding);
                let y = startY + row * (circleSize + padding);
                
                // Si la columna excede el l칤mite, pasa a la siguiente fila
                if (col >= maxCols) {
                    col = 0;
                    row++;
                    x = padding + circleSize / 2 + col * (circleSize + padding);
                    y = startY + row * (circleSize + padding);
                }

                circles.push({
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y,
                    size: circleSize,
                    inTarget: -1, // -1 si no est치 en ning칰n rect치ngulo, o el ID del rect치ngulo
                    isDragging: false,
                    // Propiedades para reposicionamiento dentro del target
                    targetIndex: -1, // Posici칩n (칤ndice 0, 1, 2...) dentro del array circlesInTarget del target
                });
                col++;
            }

            // 4. Actualizar el mensaje del problema
            let expectedCount = numCircles / numTargets;
            document.getElementById('problem-text').innerHTML = `
                El objetivo es **repartir** los **${numCircles} c칤rculos** de abajo
                en los **${numTargets} rect치ngulos** de arriba.
                <br>
                쮺u치ntos c칤rculos debe tener cada rect치ngulo para que el reparto sea equitativo?
            `;
        }

        /**
         * Bucle de dibujo de p5.js
         */
        function draw() {
            background(230, 235, 240); // Fondo del canvas

            // 1. Dibujar rect치ngulos (Targets/Grupos)
            targets.forEach(t => {
                // Dibujar el contenedor
                noFill();
                stroke(59, 130, 246); // Azul
                strokeWeight(4);
                rect(t.x, t.y, t.w, t.h, 10); // 10 es el radio del borde redondeado

                // Mostrar el conteo
                fill(59, 130, 246);
                noStroke();
                textSize(18);
                textAlign(CENTER, TOP);
                text(`Grupo ${t.id + 1}:`, t.x + t.w / 2, t.y + 10); // T칤tulo en la parte superior del target
                text(`${t.count} c칤rculos`, t.x + t.w / 2, t.y + t.h - 30); // Conteo en la parte inferior
            });

            // 2. Dibujar c칤rculos (Objetos)
            circles.forEach(c => {
                // Color del c칤rculo
                if (c.inTarget !== -1) {
                    // C칤rculo dentro de un rect치ngulo
                    fill(252, 165, 165); // Rosa claro
                    stroke(239, 68, 68); // Rojo
                } else if (c.isDragging) {
                    // C칤rculo arrastr치ndose
                    fill(255, 255, 100); // Amarillo brillante
                    stroke(255, 165, 0); // Naranja
                } else {
                    // C칤rculo en posici칩n inicial
                    fill(150, 200, 250); // Azul claro
                    stroke(59, 130, 246); // Azul
                }
                
                strokeWeight(2);
                
                // Si se est치 arrastrando, dibuja en la posici칩n del mouse
                if (c.isDragging) {
                     ellipse(mouseX, mouseY, c.size);
                } else {
                    // Si est치 quieto, dibuja en su posici칩n fija (original o en la grilla del target)
                    ellipse(c.x, c.y, c.size);
                }
            });

            // Asegurar que el c칤rculo arrastrado se dibuje al final (encima de todo)
            // No es necesario ya que el arrastre se maneja dibujando en la posici칩n del mouse
            // dentro del bucle de circles.
        }

        // --- Manejo de Interacci칩n (Arrastre) ---

        function mousePressed() {
            // Revisa si se est치 presionando sobre alg칰n c칤rculo
            for (let i = circles.length - 1; i >= 0; i--) {
                let c = circles[i];
                // Ignorar el c칤rculo si ya est치 siendo arrastrado (aunque no deber칤a pasar)
                if (c.isDragging) continue;

                let d = dist(mouseX, mouseY, c.x, c.y);

                if (d < c.size / 2) {
                    // Reinicia el estado del grupo de conteo antes de arrastrar
                    if (c.inTarget !== -1) {
                        let currentTarget = targets[c.inTarget];
                        
                        // Quitar de la lista de c칤rculos del target
                        currentTarget.circlesInTarget.splice(c.targetIndex, 1);
                        currentTarget.count--;

                        // Actualizar los 칤ndices de los c칤rculos restantes en ese target
                        currentTarget.circlesInTarget.forEach((cc, idx) => {
                            cc.targetIndex = idx;
                            let newPos = calculateGridPosition(currentTarget, idx);
                            cc.x = newPos.x;
                            cc.y = newPos.y;
                        });

                        c.inTarget = -1; // Lo marca como fuera de grupo
                        c.targetIndex = -1;
                    }
                    
                    draggedCircle = c;
                    draggedCircle.isDragging = true;
                    isDragging = true;
                    
                    // Mueve el c칤rculo arrastrado al final del array para que se dibuje encima
                    circles.splice(i, 1);
                    circles.push(draggedCircle);
                    break;
                }
            }
        }

        function mouseDragged() {
            if (draggedCircle) {
                // Actualiza la posici칩n interna del objeto mientras se arrastra
                draggedCircle.x = mouseX;
                draggedCircle.y = mouseY;
            }
        }

        function mouseReleased() {
            if (draggedCircle) {
                let foundTarget = false;

                // 1. Revisar si el c칤rculo cay칩 en alg칰n rect치ngulo (target)
                targets.forEach(t => {
                    if (mouseX > t.x && mouseX < t.x + t.w &&
                        mouseY > t.y && mouseY < t.y + t.h) {
                        
                        // C칤rculo soltado en un rect치ngulo: Asignar al grupo
                        
                        // NUEVO: Calcular la posici칩n en la grilla
                        let newIndex = t.circlesInTarget.length;
                        let newPos = calculateGridPosition(t, newIndex);
                        
                        draggedCircle.x = newPos.x;
                        draggedCircle.y = newPos.y;
                        
                        draggedCircle.inTarget = t.id;
                        draggedCircle.targetIndex = newIndex; // Guardar su 칤ndice de posici칩n
                        
                        t.count++;
                        t.circlesInTarget.push(draggedCircle); // A침adir a la lista del target
                        foundTarget = true;
                    }
                });

                if (!foundTarget) {
                    // 2. Si no cay칩 en un rect치ngulo: devolver a su posici칩n original
                    draggedCircle.x = draggedCircle.originalX;
                    draggedCircle.y = draggedCircle.originalY;
                    draggedCircle.inTarget = -1;
                    draggedCircle.targetIndex = -1;
                }
                
                draggedCircle.isDragging = false;
                draggedCircle = null;
                isDragging = false;
                
                // Limpiar mensaje si hay alguno
                messageDiv.textContent = "";
                messageDiv.className = "message";
            }
        }

        /**
         * Verifica si todos los c칤rculos han sido repartidos equitativamente.
         */
        function checkReparto() {
            // El reparto equitativo es el n칰mero de c칤rculos dividido por el n칰mero de rect치ngulos
            let expectedCount = numCircles / numTargets;
            let allCirclesPlaced = true;
            let isEquitable = true;

            // 1. Verificar que todos los c칤rculos est칠n colocados
            circles.forEach(c => {
                if (c.inTarget === -1) {
                    allCirclesPlaced = false;
                }
            });

            if (!allCirclesPlaced) {
                showMessage("춰Ups! A칰n quedan c칤rculos sin repartir. 춰No te olvides de ninguno!", "error");
                return;
            }

            // 2. Verificar que el conteo en cada grupo sea el esperado
            targets.forEach(t => {
                if (t.count !== expectedCount) {
                    isEquitable = false;
                }
            });

            if (isEquitable) {
                showMessage(`춰Excelente trabajo! Has repartido ${numCircles} c칤rculos entre ${numTargets} grupos, d치ndole ${expectedCount} a cada uno.`, "success");
            } else {
                showMessage(`Casi lo logras. Los ${numCircles} c칤rculos no est치n repartidos equitativamente entre los ${numTargets} grupos. 춰Int칠ntalo de nuevo!`, "error");
            }
        }
        
        /**
         * Muestra mensajes de estado y feedback al usuario.
         * @param {string} text - Mensaje a mostrar.
         * @param {string} type - 'success' o 'error'.
         */
        function showMessage(text, type) {
            messageDiv.textContent = text;
            messageDiv.className = `message message-${type}`;
        }
    </script>
</body>
</html>