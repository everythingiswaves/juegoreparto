<!--
  Juego interactivo de Reparto Equitativo para segundo grado (p5.js).
  Permite a los alumnos arrastrar c칤rculos a rect치ngulos (grupos)
  y verifica si el reparto ha sido equitativo.

  EDICI칍N: Se ha implementado responsividad para pantallas peque침as (tabletas)
  en modo horizontal, ajustando el tama침o del canvas y los elementos.
-->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reparto Equitativo con C칤rculos</title>
    <!-- Carga de la librer칤a p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Estilos usando Tailwind CSS (cargado via CDN) para la interfaz */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            /* Flexbox principal centrado */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; /* Fondo suave */
            font-family: 'Inter', sans-serif;
            flex-direction: column;
            overflow: hidden; /* Evitar barras de desplazamiento accidentales */
            padding: 5px; /* Peque침o padding general */
        }
        
        /* Contenedor del Canvas para control de tama침o */
        #p5-canvas-container {
            border: 4px solid #3b82f6; /* Borde azul llamativo */
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Importante: permite que el canvas se dimensione din치micamente */
            width: 95%; 
            max-width: 900px; 
            margin-bottom: 10px;
        }

        /* Asegurar que el canvas de p5.js dentro del contenedor tome el 100% */
        canvas {
            display: block; 
            width: 100%;
            height: auto;
        }

        .instructions {
            background-color: #ffffff;
            padding: 0.75rem; /* Menos padding en m칩vil */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            text-align: center;
            width: 95%;
            max-width: 900px;
            margin-bottom: 10px;
        }
        h2 {
            font-size: 1.25rem; /* T칤tulos m치s peque침os en m칩vil */
        }
        .controls {
            display: flex;
            gap: 0.75rem; /* Menos espacio entre botones */
            justify-content: center;
            margin-top: 5px;
        }
        .btn {
            padding: 0.6rem 1.2rem; /* Botones m치s peque침os */
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            box-shadow: 0 3px #1d4ed8;
            font-size: 0.9rem; /* Fuente m치s peque침a */
        }
        .btn-check {
            background-color: #4ade80; /* Verde brillante */
            color: #166534;
        }
        .btn-check:hover {
            background-color: #10b981;
            box-shadow: 0 1px #065f46;
            transform: translateY(2px);
        }
        .btn-reset {
            background-color: #facc15; /* Amarillo */
            color: #713f12;
        }
        .btn-reset:hover {
            background-color: #f59e0b;
            box-shadow: 0 1px #b45309;
            transform: translateY(2px);
        }
        #message {
            margin-top: 10px;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            min-height: 20px;
            width: 95%;
            max-width: 800px;
            text-align: center;
        }
        .message-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        .message-error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
    </style>
</head>
<body>

    <div class="instructions">
        <h2>游꿡 춰A Repartir C칤rculos!</h2>
        <p id="problem-text">
            El objetivo es **repartir** todos los c칤rculos de abajo en los rect치ngulos de arriba,
            asegurando que **cada rect치ngulo quede con la misma cantidad** de c칤rculos.
        </p>
    </div>

    <div id="p5-canvas-container"></div>

    <div id="message"></div>

    <div class="controls">
        <button class="btn btn-check" onclick="checkReparto()">춰Comprobar!</button>
        <button class="btn btn-reset" onclick="resetGame()">Nuevo Reto</button>
    </div>

    <script>
        // --- Variables Globales del Juego ---
        let circles = []; // Array de c칤rculos (objetos a repartir)
        let targets = []; // Array de rect치ngulos (grupos receptores)
        let numCircles;
        let numTargets;
        let circleSize = 25; // REDUCIDO para pantallas peque침as
        let padding = 15; // REDUCIDO
        let canvasWidth = 800; // Valores iniciales
        let canvasHeight = 550; // Valores iniciales
        let isDragging = false;
        let draggedCircle = null;
        let messageDiv;
        
        // Par치metros de la grilla dentro de los rect치ngulos (Targets)
        const gridSpacing = 30; // Espacio entre centros de c칤rculos (REDIMENSIONADO)
        const circlesPerRowCount = 2; // M치ximo de c칤rculos por fila dentro del target

        // --- Funciones de Utilidad ---

        /**
         * Calcula las coordenadas X, Y para centrar un c칤rculo en una grilla de un Target.
         */
        function calculateGridPosition(target, index) {
            // Posici칩n relativa a 0,0 del target
            let col = index % circlesPerRowCount;
            let row = floor(index / circlesPerRowCount);
            
            // Margen inicial para centrar la peque침a grilla
            // Esto ajusta la posici칩n inicial para que la grilla quede centrada horizontalmente
            let startX = target.x + (target.w / 2) - ((circlesPerRowCount - 1) * gridSpacing / 2);
            // Esto ajusta la posici칩n inicial para que la grilla quede centrada verticalmente
            let startY = target.y + (target.h / 2) - (gridSpacing / 2); 
            
            // Coordenadas absolutas
            return {
                x: startX + col * gridSpacing,
                y: startY + row * gridSpacing
            };
        }


        // --- Configuraci칩n Inicial ---

        function setup() {
            // 1. Detecci칩n de tama침o de ventana para hacerlo responsivo
            // Usamos un 95% del ancho de la ventana y ajustamos la altura proporcionalmente.
            let containerWidth = document.getElementById('p5-canvas-container').offsetWidth;
            canvasWidth = containerWidth;
            // Mantenemos una relaci칩n de aspecto para que se vea bien en horizontal (aprox 1.6:1)
            canvasHeight = min(windowHeight * 0.7, containerWidth * 0.65);
            canvasHeight = max(canvasHeight, 350); // M칤nimo para que quepan elementos

            // Crea el lienzo de p5.js
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('p5-canvas-container'); // Adjunta el canvas al div contenedor
            messageDiv = document.getElementById('message');
            
            // Configurar p5.js para manejar redimensionamiento (ejecuta redraw)
            windowResized(); 

            resetGame();
        }
        
        // Manejador de redimensionamiento de ventana (muy importante para la responsividad)
        function windowResized() {
            // Recalcula el tama침o del canvas basado en el contenedor
            let containerWidth = document.getElementById('p5-canvas-container').offsetWidth;
            canvasWidth = containerWidth;
            canvasHeight = min(windowHeight * 0.7, containerWidth * 0.65);
            canvasHeight = max(canvasHeight, 350);
            resizeCanvas(canvasWidth, canvasHeight);
            
            // Reajusta todos los elementos a la nueva escala y posici칩n
            resetGame(true); // Pasar true para indicar que solo se reposicione, no cambie los n칰meros
        }


        /**
         * Inicializa o reinicia el juego generando nuevos n칰meros y objetos.
         * @param {boolean} keepNumbers - Si es true, mantiene numCircles y numTargets.
         */
        function resetGame(keepNumbers = false) {
            
            if (!keepNumbers) {
                // 1. Generar n칰meros aleatorios para c칤rculos y rect치ngulos
                numTargets = floor(random(2, 6)); // Grupos entre 2 y 5

                let multiples = [];
                for (let i = 2; i <= 4; i++) { // Cocientes posibles: 2, 3, 4
                    let value = numTargets * i;
                    if (value >= 8 && value <= 20) {
                        multiples.push(value);
                    }
                }
                if (multiples.length > 0) {
                    numCircles = random(multiples);
                } else {
                    // Fallback
                    numTargets = 3;
                    numCircles = 12;
                }
            }

            // Limpiar arrays
            circles = [];
            targets = [];
            messageDiv.textContent = "";
            messageDiv.className = "message";
            
            // 2. Crear los rect치ngulos (Targets) en la parte superior
            // Altura y ancho basados en las nuevas dimensiones del canvas
            let targetHeight = canvasHeight * 0.3; // 30% de la altura
            let targetY = padding;
            let targetWidth = (canvasWidth - padding * (numTargets + 1)) / numTargets;

            for (let i = 0; i < numTargets; i++) {
                let x = padding + i * (targetWidth + padding);
                targets.push({
                    x: x,
                    y: targetY,
                    w: targetWidth,
                    h: targetHeight,
                    count: 0, 
                    id: i,
                    circlesInTarget: [], 
                });
            }

            // 3. Crear los c칤rculos (Objects) en la parte inferior
            // Se colocar치n en una cuadr칤cula en la parte inferior del canvas.
            let startY = canvasHeight - canvasHeight * 0.2; // 20% desde el fondo
            let maxCols = floor(canvasWidth / (circleSize + padding));
            let col = 0;
            let row = 0;
            
            // Reajustamos el tama침o del texto para que se vea bien en m칩vil
            let targetFontSize = min(18, canvasWidth / (numTargets * 10));

            for (let i = 0; i < numCircles; i++) {
                let x = padding + circleSize / 2 + col * (circleSize + padding);
                let y = startY + row * (circleSize + padding);
                
                // Si la columna excede el l칤mite, pasa a la siguiente fila
                if (col >= maxCols) {
                    col = 0;
                    row++;
                    x = padding + circleSize / 2 + col * (circleSize + padding);
                    y = startY + row * (circleSize + padding);
                }

                circles.push({
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y: y,
                    size: circleSize,
                    inTarget: -1, 
                    isDragging: false,
                    targetIndex: -1, 
                });
                col++;
            }
            
            // 4. Si estamos re-dibujando, re-colocamos los c칤rculos en sus targets
            if (keepNumbers) {
                 // Esta l칩gica es para reajustar los c칤rculos ya colocados.
                 // Como no guardamos el estado del conteo en un lugar persistente fuera de `circles`,
                 // el `resetGame(true)` se usa principalmente para `windowResized`, donde p5.js llama a `draw()`
                 // y el estado de los c칤rculos deber칤a persistir por un momento, pero en un entorno iframe,
                 // un resize completo puede resetear el canvas y las variables. 
                 // Para este caso, solo generamos nuevos retos al redimensionar para garantizar estabilidad.
            }

            // 5. Actualizar el mensaje del problema
            let expectedCount = numCircles / numTargets;
            document.getElementById('problem-text').innerHTML = `
                El objetivo es **repartir** los **${numCircles} c칤rculos** de abajo
                en los **${numTargets} rect치ngulos** de arriba.
                <br>
                쮺u치ntos c칤rculos debe tener cada rect치ngulo para que el reparto sea equitativo?
            `;
        }

        /**
         * Bucle de dibujo de p5.js
         */
        function draw() {
            background(230, 235, 240); // Fondo del canvas
            
            // Reajustamos el tama침o del texto para que se vea bien en m칩vil
            let targetFontSize = min(18, canvasWidth / (numTargets * 10));
            
            // 1. Dibujar rect치ngulos (Targets/Grupos)
            targets.forEach(t => {
                // Dibujar el contenedor
                noFill();
                stroke(59, 130, 246); // Azul
                strokeWeight(4);
                rect(t.x, t.y, t.w, t.h, 10); // 10 es el radio del borde redondeado

                // Mostrar el conteo
                fill(59, 130, 246);
                noStroke();
                textSize(targetFontSize); // Usar tama침o de fuente adaptativo
                textAlign(CENTER, TOP);
                text(`Grupo ${t.id + 1}:`, t.x + t.w / 2, t.y + 5); // T칤tulo en la parte superior del target
                text(`${t.count} c칤rculos`, t.x + t.w / 2, t.y + t.h - 20); // Conteo en la parte inferior
            });

            // 2. Dibujar c칤rculos (Objetos)
            circles.forEach(c => {
                // Color del c칤rculo
                if (c.inTarget !== -1) {
                    // C칤rculo dentro de un rect치ngulo
                    fill(252, 165, 165); // Rosa claro
                    stroke(239, 68, 68); // Rojo
                } else if (c.isDragging) {
                    // C칤rculo arrastr치ndose
                    fill(255, 255, 100); // Amarillo brillante
                    stroke(255, 165, 0); // Naranja
                } else {
                    // C칤rculo en posici칩n inicial
                    fill(150, 200, 250); // Azul claro
                    stroke(59, 130, 246); // Azul
                }
                
                strokeWeight(2);
                
                // Si se est치 arrastrando, dibuja en la posici칩n del mouse
                if (c.isDragging) {
                     ellipse(mouseX, mouseY, c.size);
                } else {
                    // Si est치 quieto, dibuja en su posici칩n fija (original o en la grilla del target)
                    ellipse(c.x, c.y, c.size);
                }
            });
        }

        // --- Manejo de Interacci칩n (Arrastre) ---

        function mousePressed() {
            // Revisa si se est치 presionando sobre alg칰n c칤rculo
            for (let i = circles.length - 1; i >= 0; i--) {
                let c = circles[i];
                // Ignorar el c칤rculo si ya est치 siendo arrastrado (aunque no deber칤a pasar)
                if (c.isDragging) continue;

                let d = dist(mouseX, mouseY, c.x, c.y);

                if (d < c.size / 2) {
                    // Reinicia el estado del grupo de conteo antes de arrastrar
                    if (c.inTarget !== -1) {
                        let currentTarget = targets[c.inTarget];
                        
                        // Quitar de la lista de c칤rculos del target
                        currentTarget.circlesInTarget.splice(c.targetIndex, 1);
                        currentTarget.count--;

                        // Actualizar los 칤ndices de los c칤rculos restantes en ese target
                        currentTarget.circlesInTarget.forEach((cc, idx) => {
                            cc.targetIndex = idx;
                            let newPos = calculateGridPosition(currentTarget, idx);
                            cc.x = newPos.x;
                            cc.y = newPos.y;
                        });

                        c.inTarget = -1; // Lo marca como fuera de grupo
                        c.targetIndex = -1;
                    }
                    
                    draggedCircle = c;
                    draggedCircle.isDragging = true;
                    isDragging = true;
                    
                    // Mueve el c칤rculo arrastrado al final del array para que se dibuje encima
                    circles.splice(i, 1);
                    circles.push(draggedCircle);
                    break;
                }
            }
        }

        function mouseDragged() {
            if (draggedCircle) {
                // Actualiza la posici칩n interna del objeto mientras se arrastra
                draggedCircle.x = mouseX;
                draggedCircle.y = mouseY;
            }
        }

        function mouseReleased() {
            if (draggedCircle) {
                let foundTarget = false;

                // 1. Revisar si el c칤rculo cay칩 en alg칰n rect치ngulo (target)
                targets.forEach(t => {
                    if (mouseX > t.x && mouseX < t.x + t.w &&
                        mouseY > t.y && mouseY < t.y + t.h) {
                        
                        // C칤rculo soltado en un rect치ngulo: Asignar al grupo
                        
                        // NUEVO: Calcular la posici칩n en la grilla
                        let newIndex = t.circlesInTarget.length;
                        let newPos = calculateGridPosition(t, newIndex);
                        
                        draggedCircle.x = newPos.x;
                        draggedCircle.y = newPos.y;
                        
                        draggedCircle.inTarget = t.id;
                        draggedCircle.targetIndex = newIndex; // Guardar su 칤ndice de posici칩n
                        
                        t.count++;
                        t.circlesInTarget.push(draggedCircle); // A침adir a la lista del target
                        foundTarget = true;
                    }
                });

                if (!foundTarget) {
                    // 2. Si no cay칩 en un rect치ngulo: devolver a su posici칩n original
                    draggedCircle.x = draggedCircle.originalX;
                    draggedCircle.y = draggedCircle.originalY;
                    draggedCircle.inTarget = -1;
                    draggedCircle.targetIndex = -1;
                }
                
                draggedCircle.isDragging = false;
                draggedCircle = null;
                isDragging = false;
                
                // Limpiar mensaje si hay alguno
                messageDiv.textContent = "";
                messageDiv.className = "message";
            }
        }

        // --- L칩gica del Juego ---

        /**
         * Verifica si todos los c칤rculos han sido repartidos equitativamente.
         */
        function checkReparto() {
            // El reparto equitativo es el n칰mero de c칤rculos dividido por el n칰mero de rect치ngulos
            let expectedCount = numCircles / numTargets;
            let allCirclesPlaced = true;
            let isEquitable = true;

            // 1. Verificar que todos los c칤rculos est칠n colocados
            circles.forEach(c => {
                if (c.inTarget === -1) {
                    allCirclesPlaced = false;
                }
            });

            if (!allCirclesPlaced) {
                showMessage("춰Ups! A칰n quedan c칤rculos sin repartir. 춰No te olvides de ninguno!", "error");
                return;
            }

            // 2. Verificar que el conteo en cada grupo sea el esperado
            targets.forEach(t => {
                if (t.count !== expectedCount) {
                    isEquitable = false;
                }
            });

            if (isEquitable) {
                showMessage(`춰Excelente trabajo! Has repartido ${numCircles} c칤rculos entre ${numTargets} grupos, d치ndole ${expectedCount} a cada uno.`, "success");
            } else {
                showMessage(`Casi lo logras. Los ${numCircles} c칤rculos no est치n repartidos equitativamente entre los ${numTargets} grupos. 춰Int칠ntalo de nuevo!`, "error");
            }
        }
        
        /**
         * Muestra mensajes de estado y feedback al usuario.
         * @param {string} text - Mensaje a mostrar.
         * @param {string} type - 'success' o 'error'.
         */
        function showMessage(text, type) {
            messageDiv.textContent = text;
            messageDiv.className = `message message-${type}`;
        }
    </script>
</body>
</html>